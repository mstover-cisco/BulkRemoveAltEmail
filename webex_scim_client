# webex_scim_client.py

import requests
import json
import os
import time # Import the time module

class WebexScimClient:
    """
    A Python client for the Webex SCIM 2.0 API, with built-in rate limit handling.
    """
    def __init__(self, org_id: str, bearer_token: str):
        if not org_id or not bearer_token:
            raise ValueError("Organization ID and Bearer Token are required.")
            
        self.base_url = f"https://api.webex.com/v1/scim/{org_id}"
        self._headers = {
            "Authorization": f"Bearer {bearer_token}",
            "Content-Type": "application/scim+json",
            "Accept": "application/scim+json"
        }

    def _make_request(self, method, endpoint, payload=None):
        """
        Helper method to make API requests with automatic retry on rate limiting.
        """
        url = f"{self.base_url}{endpoint}"
        while True: # Loop to allow for retries
            try:
                if payload:
                    response = requests.request(method, url, headers=self._headers, data=json.dumps(payload))
                else:
                    response = requests.request(method, url, headers=self._headers)
                
                # This will raise an HTTPError for 4xx/5xx responses
                response.raise_for_status()
                
                if response.status_code == 204:
                    return None # Success with no content
                return response.json() # Success with content
            
            except requests.exceptions.HTTPError as e:
                # Check specifically for the rate limit status code
                if e.response.status_code == 429:
                    # Get the Retry-After header value, default to 5 seconds if not present
                    retry_after = int(e.response.headers.get("Retry-After", 5))
                    print(f"--- Rate limit hit. Waiting for {retry_after} seconds before retrying. ---")
                    time.sleep(retry_after)
                    continue # Retry the request by continuing the while loop
                else:
                    # For any other HTTP error, print it and re-raise the exception
                    print(f"HTTP Error: {e.response.status_code} - {e.response.text}")
                    raise e
            
            except requests.exceptions.RequestException as e:
                print(f"Request failed: {e}")
                raise e

    # --- All other methods (create_user, list_users, etc.) remain the same ---
    # They will now automatically benefit from the rate-limiting logic.
    
    def list_users(self, filter_query: str):
        """Lists users with a filter. Simplified for this use case."""
        endpoint = f"/Users?filter={filter_query}"
        url = f"{self.base_url}{endpoint}"
        # This GET request does not use the payload
        return self._make_request("GET", endpoint)

    def remove_email_from_user(self, user_id: str, email_to_remove: str):
        """Removes a specific email address from an existing user."""
        path_expression = f'emails[value eq "{email_to_remove}"]'
        patch_data = {
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
            "Operations": [
                {
                    "op": "remove",
                    "path": path_expression
                }
            ]
        }
        return self._make_request("PATCH", f"/Users/{user_id}", payload=patch_data)

